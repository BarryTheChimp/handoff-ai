// Handoff AI - Prisma Schema
// Transforms specification documents into structured Jira tickets

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// =============================================================================
// ENUMS
// =============================================================================

enum SpecStatus {
  uploaded
  extracting
  ready
  translating
  translated
  error
}

enum WorkItemType {
  epic
  feature
  story
}

enum WorkItemStatus {
  draft
  ready_for_review
  approved
  exported
}

enum SizeEstimate {
  S
  M
  L
  XL
}

// =============================================================================
// ENTITIES
// =============================================================================

/// Project - Top-level container for specs and settings
model Project {
  id              String   @id @default(uuid())
  name            String
  description     String?  @db.Text
  jiraProjectKey  String?  @map("jira_project_key")
  settings        Json     @default("{}")
  createdAt       DateTime @default(now()) @map("created_at")
  updatedAt       DateTime @updatedAt @map("updated_at")

  // Relations
  specs              Spec[]
  specGroups         SpecGroup[]
  templates          StoryTemplate[]
  preferences        TeamPreference[]
  knowledge          ProjectKnowledge?
  glossary           GlossaryTerm[]
  referenceDocuments ReferenceDocument[]
  preferencesConfig  TeamPreferencesConfig?
  contextSources     ContextSource[]
  contextChunks      ContextChunk[]
  storyEdits         StoryEdit[]
  learnedPatterns    LearnedPattern[]
  health             ProjectHealth?
  duplicateMatches   DuplicateMatch[]

  @@map("projects")
}

/// Spec - An uploaded specification document
model Spec {
  id            String     @id @default(uuid())
  projectId     String     @map("project_id")
  specGroupId   String?    @map("spec_group_id")
  name          String
  filePath      String     @map("file_path")
  fileType      String     @map("file_type")
  fileSize      Int        @map("file_size")
  extractedText String?    @map("extracted_text") @db.Text
  status        SpecStatus @default(uploaded)
  specType      String     @default("api-spec") @map("spec_type")
  uploadedBy    String     @map("uploaded_by")
  uploadedAt    DateTime   @default(now()) @map("uploaded_at")
  metadata      Json       @default("{}")
  errorMessage  String?    @map("error_message")

  // Relations
  project   Project       @relation(fields: [projectId], references: [id], onDelete: Cascade)
  specGroup SpecGroup?    @relation(fields: [specGroupId], references: [id], onDelete: SetNull)
  sections  SpecSection[]
  workItems WorkItem[]

  @@index([projectId])
  @@index([specGroupId])
  @@index([status])
  @@map("specs")
}

/// SpecSection - A section/heading extracted from a spec document
model SpecSection {
  id                     String  @id @default(uuid())
  specId                 String  @map("spec_id")
  sectionRef             String  @map("section_ref") // e.g., "1.2.3" or "API-001"
  heading                String
  content                String  @db.Text
  orderIndex             Int     @map("order_index")
  intentionallyUncovered Boolean @default(false) @map("intentionally_uncovered")

  // Relations
  spec             Spec             @relation(fields: [specId], references: [id], onDelete: Cascade)
  workItemSources  WorkItemSource[]

  @@index([specId])
  @@map("spec_sections")
}

/// WorkItem - An Epic, Feature, or Story generated from the spec
model WorkItem {
  id                 String         @id @default(uuid())
  specId             String         @map("spec_id")
  parentId           String?        @map("parent_id")
  type               WorkItemType
  title              String
  description        String?        @db.Text
  acceptanceCriteria String?        @map("acceptance_criteria") @db.Text
  technicalNotes     String?        @map("technical_notes") @db.Text
  sizeEstimate       SizeEstimate?  @map("size_estimate")
  status             WorkItemStatus @default(draft)
  orderIndex         Int            @map("order_index")
  jiraKey            String?        @map("jira_key")
  templateId         String?        @map("template_id")
  customFields       Json           @default("{}") @map("custom_fields")
  dependsOnIds       String[]       @default([]) @map("depends_on_ids")
  createdAt          DateTime       @default(now()) @map("created_at")
  updatedAt          DateTime       @updatedAt @map("updated_at")

  // Self-referencing relation for hierarchy
  parent   WorkItem?  @relation("WorkItemHierarchy", fields: [parentId], references: [id], onDelete: SetNull)
  children WorkItem[] @relation("WorkItemHierarchy")

  // Relations
  spec     Spec               @relation(fields: [specId], references: [id], onDelete: Cascade)
  sources  WorkItemSource[]
  history  WorkItemHistory[]
  feedback AIFeedback[]
  edits    StoryEdit[]
  sourceDuplicates DuplicateMatch[] @relation("SourceDuplicate")
  targetDuplicates DuplicateMatch[] @relation("TargetDuplicate")

  @@index([specId])
  @@index([parentId])
  @@index([type])
  @@index([status])
  @@map("work_items")
}

/// WorkItemSource - Junction table linking work items to spec sections
model WorkItemSource {
  workItemId     String  @map("work_item_id")
  sectionId      String  @map("section_id")
  relevanceScore Float   @default(1.0) @map("relevance_score")

  // Relations
  workItem WorkItem    @relation(fields: [workItemId], references: [id], onDelete: Cascade)
  section  SpecSection @relation(fields: [sectionId], references: [id], onDelete: Cascade)

  @@id([workItemId, sectionId])
  @@map("work_item_sources")
}

/// WorkItemHistory - Audit trail for work item changes
model WorkItemHistory {
  id           String   @id @default(uuid())
  workItemId   String   @map("work_item_id")
  fieldChanged String   @map("field_changed")
  oldValue     String?  @map("old_value") @db.Text
  newValue     String?  @map("new_value") @db.Text
  changedBy    String   @map("changed_by")
  changedAt    DateTime @default(now()) @map("changed_at")

  // Relations
  workItem WorkItem @relation(fields: [workItemId], references: [id], onDelete: Cascade)

  @@index([workItemId])
  @@index([changedAt])
  @@map("work_item_history")
}

/// JiraConnection - Stores OAuth tokens for Jira integration (encrypted)
model JiraConnection {
  id           String   @id @default(uuid())
  userId       String   @unique @map("user_id")
  accessToken  String   @map("access_token") @db.Text
  refreshToken String   @map("refresh_token") @db.Text
  expiresAt    DateTime @map("expires_at")
  cloudId      String   @map("cloud_id")
  siteUrl      String?  @map("site_url")
  createdAt    DateTime @default(now()) @map("created_at")
  updatedAt    DateTime @updatedAt @map("updated_at")

  @@map("jira_connections")
}

enum ExportStatus {
  pending
  in_progress
  completed
  failed
  cancelled
}

// =============================================================================
// SPEC GROUPS (Multi-File Upload)
// =============================================================================

enum SpecGroupStatus {
  pending
  analyzing
  conflicts_detected
  ready
  error
}

/// SpecGroup - A collection of related spec documents
model SpecGroup {
  id              String          @id @default(uuid())
  projectId       String          @map("project_id")
  name            String
  primarySpecId   String?         @map("primary_spec_id")
  stitchedContext String?         @db.Text @map("stitched_context")
  status          SpecGroupStatus @default(pending)
  errorMessage    String?         @db.Text @map("error_message")
  createdAt       DateTime        @default(now()) @map("created_at")
  updatedAt       DateTime        @updatedAt @map("updated_at")

  // Relations
  project   Project        @relation(fields: [projectId], references: [id], onDelete: Cascade)
  specs     Spec[]
  conflicts SpecConflict[]

  @@index([projectId])
  @@index([status])
  @@map("spec_groups")
}

/// SpecConflict - A detected conflict between specs in a group
model SpecConflict {
  id           String    @id @default(uuid())
  specGroupId  String    @map("spec_group_id")
  spec1Id      String    @map("spec1_id")
  spec1Section String    @map("spec1_section")
  spec1Text    String    @db.Text @map("spec1_text")
  spec2Id      String    @map("spec2_id")
  spec2Section String    @map("spec2_section")
  spec2Text    String    @db.Text @map("spec2_text")
  conflictType String    @map("conflict_type")
  severity     String    @default("warning")
  description  String    @db.Text
  resolution   String?
  mergedText   String?   @db.Text @map("merged_text")
  resolvedBy   String?   @map("resolved_by")
  resolvedAt   DateTime? @map("resolved_at")

  // Relations
  specGroup SpecGroup @relation(fields: [specGroupId], references: [id], onDelete: Cascade)

  @@index([specGroupId])
  @@index([resolution])
  @@map("spec_conflicts")
}

/// Export - Tracks a Jira export job
model Export {
  id              String       @id @default(uuid())
  specId          String       @map("spec_id")
  userId          String       @map("user_id")
  jiraProjectKey  String       @map("jira_project_key")
  status          ExportStatus @default(pending)
  isDryRun        Boolean      @default(false) @map("is_dry_run")

  // Progress tracking
  totalItems      Int          @default(0) @map("total_items")
  processedItems  Int          @default(0) @map("processed_items")
  failedItems     Int          @default(0) @map("failed_items")

  // Results
  results         Json         @default("[]") // Array of { workItemId, jiraKey, status, error? }
  errorMessage    String?      @map("error_message") @db.Text

  // Timestamps
  startedAt       DateTime?    @map("started_at")
  completedAt     DateTime?    @map("completed_at")
  createdAt       DateTime     @default(now()) @map("created_at")

  @@index([specId])
  @@index([userId])
  @@index([status])
  @@map("exports")
}

// =============================================================================
// BULK OPERATIONS
// =============================================================================

/// BulkOperation - Stores bulk operation data for undo functionality
model BulkOperation {
  id             String   @id @default(uuid())
  userId         String   @map("user_id")
  specId         String   @map("spec_id")
  operation      String   // 'update_fields' | 'ai_enhance'
  itemIds        String[] @map("item_ids")
  payload        Json     // What was applied
  previousValues Json     @map("previous_values") // For undo
  createdAt      DateTime @default(now()) @map("created_at")
  expiresAt      DateTime @map("expires_at")

  @@index([userId])
  @@index([specId])
  @@index([expiresAt])
  @@map("bulk_operations")
}

// =============================================================================
// STORY TEMPLATES
// =============================================================================

/// StoryTemplate - Template for generating stories with specific format
model StoryTemplate {
  id               String   @id @default(uuid())
  projectId        String   @map("project_id")
  name             String
  isDefault        Boolean  @default(false) @map("is_default")
  acFormat         String   @default("bullets") @map("ac_format") // 'gherkin', 'bullets', 'checklist'
  requiredSections String[] @default([]) @map("required_sections")
  customFields     Json     @default("[]") @map("custom_fields")
  createdAt        DateTime @default(now()) @map("created_at")
  updatedAt        DateTime @updatedAt @map("updated_at")

  // Relations
  project Project @relation(fields: [projectId], references: [id], onDelete: Cascade)

  @@unique([projectId, name])
  @@index([projectId])
  @@map("story_templates")
}

// =============================================================================
// AI FEEDBACK & LEARNING
// =============================================================================

/// AIFeedback - User feedback on AI-generated work items
model AIFeedback {
  id          String   @id @default(uuid())
  workItemId  String   @map("work_item_id")
  userId      String   @map("user_id")
  rating      Int      // 1 (thumbs down) or 5 (thumbs up)
  feedback    String?  @db.Text
  categories  String[] @default([])
  createdAt   DateTime @default(now()) @map("created_at")
  updatedAt   DateTime @updatedAt @map("updated_at")

  // Relations
  workItem WorkItem @relation(fields: [workItemId], references: [id], onDelete: Cascade)

  @@unique([workItemId, userId])
  @@index([workItemId])
  @@index([userId])
  @@map("ai_feedback")
}

/// TeamPreference - Learned or manual preferences for AI generation
model TeamPreference {
  id          String   @id @default(uuid())
  projectId   String   @map("project_id")
  preference  String   @db.Text
  description String?  @db.Text
  category    String?
  learnedFrom String[] @default([]) @map("learned_from")
  active      Boolean  @default(false)
  createdAt   DateTime @default(now()) @map("created_at")

  // Relations
  project Project @relation(fields: [projectId], references: [id], onDelete: Cascade)

  @@index([projectId])
  @@index([active])
  @@map("team_preferences")
}

// =============================================================================
// KNOWLEDGE BASE MODELS
// =============================================================================

/// ProjectKnowledge - Core project context (brief)
model ProjectKnowledge {
  id             String    @id @default(uuid())
  projectId      String    @unique @map("project_id")

  // Project Brief (markdown)
  brief          String?   @db.Text
  briefUpdatedAt DateTime? @map("brief_updated_at")

  // Timestamps
  createdAt      DateTime  @default(now()) @map("created_at")
  updatedAt      DateTime  @updatedAt @map("updated_at")

  // Relations
  project        Project   @relation(fields: [projectId], references: [id], onDelete: Cascade)

  @@map("project_knowledge")
}

/// GlossaryTerm - Domain terminology
model GlossaryTerm {
  id           String   @id @default(uuid())
  projectId    String   @map("project_id")

  // Term details
  term         String
  definition   String   @db.Text
  aliases      String[] @default([])
  category     String?

  // Usage hints for AI
  useInstead   String?  @map("use_instead")
  avoidTerms   String[] @default([]) @map("avoid_terms")

  // Source tracking (for auto-extracted terms)
  isManual     Boolean  @default(true) @map("is_manual")
  sourceSpecId String?  @map("source_spec_id")
  confidence   Float?

  // Timestamps
  createdAt    DateTime @default(now()) @map("created_at")
  updatedAt    DateTime @updatedAt @map("updated_at")

  // Relations
  project      Project  @relation(fields: [projectId], references: [id], onDelete: Cascade)

  @@unique([projectId, term])
  @@index([projectId])
  @@index([category])
  @@map("glossary_terms")
}

enum DocumentType {
  architecture
  process
  technical
  business
  other
}

/// ReferenceDocument - Uploaded context documents
model ReferenceDocument {
  id            String       @id @default(uuid())
  projectId     String       @map("project_id")

  // File info
  name          String
  fileName      String       @map("file_name")
  filePath      String       @map("file_path")
  fileType      String       @map("file_type")
  fileSize      Int          @map("file_size")

  // Extracted content
  extractedText String?      @db.Text @map("extracted_text")
  summary       String?      @db.Text

  // Metadata
  docType       DocumentType @default(other) @map("doc_type")
  isActive      Boolean      @default(true) @map("is_active")

  // Timestamps
  uploadedAt    DateTime     @default(now()) @map("uploaded_at")
  uploadedBy    String       @map("uploaded_by")

  // Relations
  project       Project      @relation(fields: [projectId], references: [id], onDelete: Cascade)
  chunks        DocumentChunk[]

  @@index([projectId])
  @@map("reference_documents")
}

/// DocumentChunk - Chunked content for retrieval
model DocumentChunk {
  id          String            @id @default(uuid())
  documentId  String            @map("document_id")

  // Chunk content
  content     String            @db.Text
  chunkIndex  Int               @map("chunk_index")

  // Metadata for retrieval
  heading     String?
  summary     String?

  // Relations
  document    ReferenceDocument @relation(fields: [documentId], references: [id], onDelete: Cascade)

  @@index([documentId])
  @@map("document_chunks")
}

enum ACFormat {
  gherkin
  bullets
  checklist
  numbered
}

enum Verbosity {
  concise
  balanced
  detailed
}

enum TechnicalDepth {
  high_level
  moderate
  implementation
}

/// TeamPreferencesConfig - Team conventions for AI
model TeamPreferencesConfig {
  id               String         @id @default(uuid())
  projectId        String         @unique @map("project_id")

  // Story Structure
  acFormat         ACFormat       @default(bullets) @map("ac_format")
  requiredSections String[]       @default([]) @map("required_sections")
  maxAcCount       Int            @default(8) @map("max_ac_count")

  // Content Style
  verbosity        Verbosity      @default(balanced)
  technicalDepth   TechnicalDepth @default(moderate) @map("technical_depth")

  // Custom preferences (freeform, learned)
  customPrefs      Json           @default("[]") @map("custom_prefs")

  // Timestamps
  updatedAt        DateTime       @updatedAt @map("updated_at")

  // Relations
  project          Project        @relation(fields: [projectId], references: [id], onDelete: Cascade)

  @@map("team_preferences_config")
}

// =============================================================================
// CONTEXT SOURCES
// =============================================================================

enum ContextSourceType {
  specs       // Other specs in project (automatic)
  jira        // Jira project
  document    // Uploaded documents
  confluence  // Future
  github      // Future
}

/// ContextSource - Registered context sources for a project
model ContextSource {
  id          String            @id @default(uuid())
  projectId   String            @map("project_id")

  // Source type and connection
  sourceType  ContextSourceType @map("source_type")
  name        String
  isEnabled   Boolean           @default(true) @map("is_enabled")

  // Connection details (JSON varies by type)
  config      Json              @default("{}")

  // Status
  lastSyncAt  DateTime?         @map("last_sync_at")
  lastError   String?           @db.Text @map("last_error")
  itemCount   Int               @default(0) @map("item_count")

  // Timestamps
  createdAt   DateTime          @default(now()) @map("created_at")
  updatedAt   DateTime          @updatedAt @map("updated_at")

  // Relations
  project     Project           @relation(fields: [projectId], references: [id], onDelete: Cascade)

  @@index([projectId])
  @@index([sourceType])
  @@map("context_sources")
}

/// ContextChunk - Searchable chunks from context sources
model ContextChunk {
  id          String            @id @default(uuid())
  projectId   String            @map("project_id")
  sourceType  ContextSourceType @map("source_type")
  sourceId    String            @map("source_id")  // ID of spec, doc, or jira ticket

  // Content
  content     String            @db.Text
  summary     String?           @db.Text
  metadata    Json              @default("{}")  // Type-specific metadata

  // For retrieval
  heading     String?
  keywords    String[]          @default([])

  // Timestamps
  createdAt   DateTime          @default(now()) @map("created_at")

  // Relations
  project     Project           @relation(fields: [projectId], references: [id], onDelete: Cascade)

  @@index([projectId])
  @@index([sourceType])
  @@index([sourceId])
  @@map("context_chunks")
}

// =============================================================================
// LEARNING LOOP
// =============================================================================

enum EditField {
  title
  description
  acceptanceCriteria
  technicalNotes
  size
  priority
}

enum EditType {
  addition     // Content added
  removal      // Content removed
  modification // Content changed
  complete     // Entire field rewritten
}

enum SuggestionType {
  addToPreferences    // Add to custom preferences
  addToGlossary       // Add term to glossary
  updateTemplate      // Update story template
  addRequiredSection  // Always include this section
}

enum PatternStatus {
  pending    // Detected, not reviewed
  suggested  // Shown to user
  accepted   // User accepted
  dismissed  // User dismissed
  applied    // Applied to preferences
}

/// StoryEdit - Tracks changes made to generated stories
model StoryEdit {
  id          String    @id @default(uuid())
  projectId   String    @map("project_id")
  workItemId  String    @map("work_item_id")

  // What changed
  field       EditField
  beforeValue String    @db.Text @map("before_value")
  afterValue  String    @db.Text @map("after_value")

  // Context
  editType    EditType  @map("edit_type")
  specId      String    @map("spec_id")
  userId      String    @map("user_id")

  // Timestamps
  createdAt   DateTime  @default(now()) @map("created_at")

  // Relations
  project     Project   @relation(fields: [projectId], references: [id], onDelete: Cascade)
  workItem    WorkItem  @relation(fields: [workItemId], references: [id], onDelete: Cascade)

  @@index([projectId])
  @@index([workItemId])
  @@index([field])
  @@map("story_edits")
}

/// LearnedPattern - Patterns detected from edits
model LearnedPattern {
  id             String         @id @default(uuid())
  projectId      String         @map("project_id")

  // Pattern details
  pattern        String         @db.Text
  description    String         @db.Text
  confidence     Float          // 0-1
  occurrences    Int            @default(1)

  // What triggered it
  field          EditField
  context        String?        // e.g., "API stories", "authentication"

  // Suggested action
  suggestion     String         @db.Text
  suggestionType SuggestionType @map("suggestion_type")

  // Status
  status         PatternStatus  @default(pending)
  reviewedAt     DateTime?      @map("reviewed_at")
  reviewedBy     String?        @map("reviewed_by")
  appliedAt      DateTime?      @map("applied_at")

  // Timestamps
  createdAt      DateTime       @default(now()) @map("created_at")
  updatedAt      DateTime       @updatedAt @map("updated_at")

  // Relations
  project        Project        @relation(fields: [projectId], references: [id], onDelete: Cascade)

  @@index([projectId])
  @@index([status])
  @@map("learned_patterns")
}

// =============================================================================
// PROJECT HEALTH
// =============================================================================

enum HealthLevel {
  minimal     // 0-25
  basic       // 26-50
  good        // 51-75
  excellent   // 76-100
}

/// ProjectHealth - Cached health score
model ProjectHealth {
  id              String      @id @default(uuid())
  projectId       String      @unique @map("project_id")

  // Overall
  score           Int         // 0-100
  level           HealthLevel

  // Components
  briefScore      Int         @map("brief_score")
  glossaryScore   Int         @map("glossary_score")
  prefsScore      Int         @map("prefs_score")
  specsScore      Int         @map("specs_score")
  sourcesScore    Int         @map("sources_score")
  learningScore   Int         @map("learning_score")

  // Recommendations
  recommendations Json        @default("[]")  // string[]

  // Timestamps
  calculatedAt    DateTime    @map("calculated_at")

  // Relations
  project         Project     @relation(fields: [projectId], references: [id], onDelete: Cascade)

  @@map("project_health")
}

// =============================================================================
// WAVE 4: USER SETTINGS
// =============================================================================

/// UserSettings - User-specific settings (branding, exports, Jira)
model UserSettings {
  id              String   @id @default(uuid())
  userId          String   @unique @map("user_id")
  branding        Json     @default("{}")
  jira            Json     @default("{}")
  exportSettings  Json     @default("{}") @map("export_settings")
  createdAt       DateTime @default(now()) @map("created_at")
  updatedAt       DateTime @updatedAt @map("updated_at")

  @@map("user_settings")
}

// =============================================================================
// WAVE 4: SPEC ANALYSIS
// =============================================================================

/// SpecAnalysis - Pre-translation analysis results
model SpecAnalysis {
  id              String   @id @default(uuid())
  specId          String   @map("spec_id")
  type            String   // 'pre_translation' | 'quality' | 'coverage'

  // Analysis data (JSON varies by type)
  data            Json     @default("{}")

  // Timestamps
  createdAt       DateTime @default(now()) @map("created_at")
  updatedAt       DateTime @updatedAt @map("updated_at")

  @@unique([specId, type])
  @@index([specId])
  @@map("spec_analyses")
}

// =============================================================================
// WAVE 4: DUPLICATE DETECTION
// =============================================================================

/// DuplicateMatch - Persisted duplicate detection results
model DuplicateMatch {
  id                String    @id @default(uuid())
  projectId         String    @map("project_id")

  // Source and target work items
  sourceWorkItemId  String    @map("source_work_item_id")
  targetWorkItemId  String?   @map("target_work_item_id")
  targetJiraKey     String?   @map("target_jira_key")

  // Match details
  similarityScore   Float     @map("similarity_score")
  matchType         String    // 'exact' | 'semantic' | 'partial'
  overlappingText   String?   @db.Text @map("overlapping_text")

  // Status tracking
  status            String    @default("pending") // 'pending' | 'ignored' | 'merged'
  reviewedAt        DateTime? @map("reviewed_at")
  reviewedBy        String?   @map("reviewed_by")

  // Timestamps
  detectedAt        DateTime  @default(now()) @map("detected_at")

  // Relations
  project           Project   @relation(fields: [projectId], references: [id], onDelete: Cascade)
  sourceWorkItem    WorkItem  @relation("SourceDuplicate", fields: [sourceWorkItemId], references: [id], onDelete: Cascade)
  targetWorkItem    WorkItem? @relation("TargetDuplicate", fields: [targetWorkItemId], references: [id], onDelete: Cascade)

  @@unique([sourceWorkItemId, targetWorkItemId])
  @@index([projectId])
  @@index([sourceWorkItemId])
  @@index([status])
  @@map("duplicate_matches")
}
